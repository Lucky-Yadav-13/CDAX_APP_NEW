// GENERATED BY CURSOR (strict) ‚Äî changed Phase 1 on 2025-09-30. ASSUMPTION: Minimal ChangeNotifier
// used as a lightweight controller without adding a global provider framework. Swap mock
// service calls with real API in services/mock_payment_service.dart when backend is ready.

import 'dart:async';
import 'dart:developer';
import 'package:flutter/foundation.dart';

import '../models/payment_result.dart';
import '../models/card_details.dart';
import '../models/netbanking_details.dart';
import '../models/transfer_details.dart';

import '../services/payment_gateway_adapter.dart';
import '../services/payment_service.dart';
import '../screens/courses/application/course_providers.dart';


// PaymentResult moved to ../models/payment_result.dart in Phase 3

enum PaymentStatus { idle, processing, success, failure }


/// ASSUMPTION: Singleton controller to avoid introducing new global provider packages.
/// Screens access the same instance via SubscriptionController.instance.
class SubscriptionController extends ChangeNotifier {
  SubscriptionController._();
  static final SubscriptionController instance = SubscriptionController._();

  String _currentPlan = '1 Month';
  PaymentStatus _status = PaymentStatus.idle;
  String? _lastMessage;
  String? selectedCourseId;
  String? selectedCourseTitle;
  double? selectedAmount;
  String? lastOrderId;
  final _courseRepo = CourseProviders.getCourseRepository();
  final _paymentGateway = PaymentGatewayAdapter.instance;
  
  // Phase 3: Additional payment state
  bool _isProcessing = false;
  PaymentResult? _lastPaymentResult;
  String? _errorMessage;

  String get currentPlan => _currentPlan;
  PaymentStatus get status => _status;
  String? get lastMessage => _lastMessage;
  
  // Phase 3: Additional getters
  bool get isProcessing => _isProcessing;
  PaymentResult? get lastPaymentResult => _lastPaymentResult;
  String? get errorMessage => _errorMessage;

  void selectPlan(String plan) {
    _currentPlan = plan;
    notifyListeners();
  }
  
  void _updateStatus(PaymentStatus status, [String? message]) {
    _status = status;
    _lastMessage = message;
    notifyListeners();
  }

  // Phase 3: Enhanced error handling
  void _setError(String error) {
    _errorMessage = error;
    _isProcessing = false;
    _updateStatus(PaymentStatus.failure, error);
  }

  void _clearError() {
    _errorMessage = null;
    notifyListeners();
  }

  // Phase 3: Set processing state
  void _setProcessing(bool processing) {
    _isProcessing = processing;
    if (processing) {
      _clearError();
      _updateStatus(PaymentStatus.processing, 'Processing payment...');
    }
    notifyListeners();
  }

  /// Phase 2: Process card payment with backend integration
  Future<void> processCardPayment({
    required CardDetails cardDetails,
    required double amount,
    String? courseId,
    String? courseTitle,
  }) async {
    _setProcessing(true);
    selectedCourseId = courseId;
    selectedCourseTitle = courseTitle;
    selectedAmount = amount;
    
    try {
      // Step 1: Create purchase order on backend
      if (courseId == null || courseTitle == null) {
        throw Exception('Course ID and title are required for payment');
      }
      
      final orderData = await PaymentService.createPurchaseOrder(
        courseId: courseId,
        courseTitle: courseTitle,
        amount: amount,
      );
      
      final backendOrderId = orderData['orderId'] as String;
      
      // Step 2: Process payment with gateway using order info
      final gatewayResult = await _paymentGateway.openCheckout(
        orderId: backendOrderId,
        amount: amount,
        currency: 'INR',
        name: courseTitle,
        description: 'Course: $courseTitle',
        notes: {
          'course_id': courseId,
          'payment_method': 'card',
        },
      );
      
      // Step 3: Verify payment with backend
      if (gatewayResult.success && gatewayResult.paymentId != null) {
        final verificationResult = await PaymentService.verifyPayment(
          orderId: backendOrderId,
          paymentId: gatewayResult.paymentId!,
          signature: gatewayResult.signature,
        );
        
        _lastPaymentResult = verificationResult;
        
        if (verificationResult.success) {
          lastOrderId = backendOrderId;
          
          // Step 4: Refresh course data to show unlocked content
          await _refreshCourseAfterPurchase(courseId);
          
          _updateStatus(PaymentStatus.success, 'Card payment successful! Order ID: $lastOrderId');
        } else {
          _setError(verificationResult.message);
        }
      } else {
        _lastPaymentResult = PaymentResult(
          success: gatewayResult.success,
          message: gatewayResult.message,
          paymentId: gatewayResult.paymentId,
          orderId: gatewayResult.orderId,
          signature: gatewayResult.signature,
        );
        _setError(gatewayResult.message);
      }
    } catch (e) {
      _setError('Card payment failed: ${e.toString()}');
    } finally {
      _setProcessing(false);
    }
  }

  /// Phase 2: Process UPI payment with backend integration
  Future<void> processUpiPayment({
    required String upiId,
    required double amount,
    String? courseId,
    String? courseTitle,
  }) async {
    _setProcessing(true);
    selectedCourseId = courseId;
    selectedCourseTitle = courseTitle;
    selectedAmount = amount;
    
    try {
      // Step 1: Create purchase order on backend
      if (courseId == null || courseTitle == null) {
        throw Exception('Course ID and title are required for payment');
      }
      
      final orderData = await PaymentService.createPurchaseOrder(
        courseId: courseId,
        courseTitle: courseTitle,
        amount: amount,
      );
      
      final backendOrderId = orderData['orderId'] as String;
      
      // Step 2: Process payment with gateway (generic method for UPI)
      final gatewayResult = await _paymentGateway.openCheckout(
        orderId: backendOrderId,
        amount: amount,
        currency: 'INR',
        name: courseTitle,
        description: 'Course: $courseTitle',
        notes: {
          'course_id': courseId,
          'payment_method': 'upi',
          'upi_id': upiId,
        },
      );
      
      // Step 3: Verify payment with backend
      if (gatewayResult.success && gatewayResult.paymentId != null) {
        final verificationResult = await PaymentService.verifyPayment(
          orderId: backendOrderId,
          paymentId: gatewayResult.paymentId!,
          signature: gatewayResult.signature,
        );
        
        _lastPaymentResult = PaymentResult(
          success: verificationResult.success,
          message: verificationResult.message,
          paymentId: gatewayResult.paymentId,
          orderId: backendOrderId,
          signature: gatewayResult.signature,
        );
        
        if (verificationResult.success) {
          lastOrderId = backendOrderId;
          
          // Step 4: Refresh course data to show unlocked content
          await _refreshCourseAfterPurchase(courseId);
          
          _updateStatus(PaymentStatus.success, 'UPI payment successful! Order ID: $lastOrderId');
        } else {
          _setError(verificationResult.message);
        }
      } else {
        _lastPaymentResult = PaymentResult(
          success: false,
          message: gatewayResult.message,
          paymentId: gatewayResult.paymentId,
          orderId: backendOrderId,
        );
        _setError(gatewayResult.message);
      }
    } catch (e) {
      _setError('UPI payment failed: ${e.toString()}');
    } finally {
      _setProcessing(false);
    }
  }

  /// Phase 2: Process netbanking payment
  Future<void> processNetBankingPayment({
    required NetbankingDetails netBankingDetails,
    required double amount,
    String? courseId,
    String? courseTitle,
  }) async {
    _setProcessing(true);
    selectedCourseId = courseId;
    selectedCourseTitle = courseTitle;
    selectedAmount = amount;
    
    try {
      final result = await _paymentGateway.processNetbankingPayment(
        bankDetails: netBankingDetails,
        amount: amount,
        currency: 'INR',
        courseId: courseId,
        courseTitle: courseTitle,
      );
      
      _lastPaymentResult = result;
      
      if (result.success) {
        lastOrderId = result.orderId ?? 'ORDER_${DateTime.now().millisecondsSinceEpoch}';
        
        if (courseId != null) {
          try {
            await _courseRepo.purchaseCourse(courseId);
          } catch (e) {
            if (kDebugMode) {
              debugPrint('Failed to mark course as purchased: $e');
            }
          }
        }
        
        _updateStatus(PaymentStatus.success, 'Net banking payment successful! Order ID: $lastOrderId');
      } else {
        _setError(result.message);
      }
    } catch (e) {
      _setError('Net banking payment failed: ${e.toString()}');
    } finally {
      _setProcessing(false);
    }
  }

  /// Phase 2: Process bank transfer payment
  Future<void> processBankTransferPayment({
    required TransferDetails transferDetails,
    required double amount,
    String? courseId,
    String? courseTitle,
  }) async {
    _setProcessing(true);
    selectedCourseId = courseId;
    selectedCourseTitle = courseTitle;
    selectedAmount = amount;
    
    try {
      final result = await _paymentGateway.processTransferPayment(
        transferDetails: transferDetails,
        amount: amount,
        currency: 'INR',
        courseId: courseId,
        courseTitle: courseTitle,
      );
      
      _lastPaymentResult = result;
      
      if (result.success) {
        lastOrderId = result.orderId ?? 'ORDER_${DateTime.now().millisecondsSinceEpoch}';
        
        if (courseId != null) {
          try {
            await _courseRepo.purchaseCourse(courseId);
          } catch (e) {
            if (kDebugMode) {
              debugPrint('Failed to mark course as purchased: $e');
            }
          }
        }
        
        _updateStatus(PaymentStatus.success, 'Bank transfer initiated! Order ID: $lastOrderId');
      } else {
        _setError(result.message);
      }
    } catch (e) {
      _setError('Bank transfer failed: ${e.toString()}');
    } finally {
      _setProcessing(false);
    }
  }

  /// Phase 3: Retry last payment (simplified)
  Future<void> retryPayment() async {
    if (_lastPaymentResult == null) {
      _setError('No previous payment to retry');
      return;
    }

    _setError('Payment retry not implemented - please try a new payment');
  }

  /// Phase 3: Reset payment state
  void resetPaymentState() {
    _status = PaymentStatus.idle;
    _lastMessage = null;
    _isProcessing = false;
    _lastPaymentResult = null;
    _errorMessage = null;
    selectedCourseId = null;
    selectedCourseTitle = null;
    selectedAmount = null;
    lastOrderId = null;
    notifyListeners();
  }

  /// Set purchase context for payment processing
  void setPurchaseContext({
    required String courseId,
    required String courseTitle,
    required double amount,
  }) {
    selectedCourseId = courseId;
    selectedCourseTitle = courseTitle;
    selectedAmount = amount;
  }

  /// Validate UPI ID format
  String? validateUpi(String? upiId) {
    if (upiId == null || upiId.isEmpty) {
      return 'UPI ID is required';
    }
    if (!RegExp(r'.+@.+').hasMatch(upiId)) {
      return 'Please enter a valid UPI ID';
    }
    return null;
  }

  /// Refresh course data after successful purchase
  /// This ensures the UI shows unlocked content immediately
  Future<void> _refreshCourseAfterPurchase(String courseId) async {
    try {
      log('üîÑ Refreshing course data after purchase...');
      final repo = CourseProviders.getCourseRepository();
      await repo.getCourseById(courseId);
      log('   ‚úÖ Course data refreshed successfully');
    } catch (e) {
      log('   ‚ö†Ô∏è Failed to refresh course data: $e');
      // Non-critical error - don't fail the payment process
    }
  }

  /// Public alias for processNetBankingPayment 
  Future<void> processNetbankingPayment({
    required NetbankingDetails netBankingDetails, 
    required double amount,
    String? courseId,
    String? courseTitle,
  }) async {
    return processNetBankingPayment(
      netBankingDetails: netBankingDetails,
      amount: amount,
      courseId: courseId,
      courseTitle: courseTitle,
    );
  }

  /// Public alias for processBankTransferPayment
  Future<void> processTransferPayment({
    required TransferDetails transferDetails,
    required double amount,
    String? courseId,
    String? courseTitle,
  }) async {
    return processBankTransferPayment(
      transferDetails: transferDetails,
      amount: amount,
      courseId: courseId,
      courseTitle: courseTitle,
    );
  }
}